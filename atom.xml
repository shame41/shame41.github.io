<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://shame41.github.io</id>
    <title>shame41</title>
    <updated>2021-03-17T05:25:50.492Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://shame41.github.io"/>
    <link rel="self" href="https://shame41.github.io/atom.xml"/>
    <subtitle>无</subtitle>
    <logo>https://shame41.github.io/images/avatar.png</logo>
    <icon>https://shame41.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, shame41</rights>
    <entry>
        <title type="html"><![CDATA[算法（第四版）笔记]]></title>
        <id>https://shame41.github.io/post/suan-fa-di-si-ban-bi-ji/</id>
        <link href="https://shame41.github.io/post/suan-fa-di-si-ban-bi-ji/">
        </link>
        <updated>2021-03-07T06:06:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="队列堆栈背包">队列/堆栈/背包</h1>
<h2 id="链表">链表</h2>
<h3 id="基本操作">基本操作</h3>
<p>没啥好说的</p>
<pre><code class="language-java">import java.util.Iterator;

//单向链表
public class LinkList&lt;Item&gt; implements Iterable&lt;Item&gt;
{
	private Node first;	//指向最早添加的结点的链接
	private Node last;	//指向最后添加的结点的链接
	private int N;		//队列中的元素数量
	
	private class Node
	{
		Item item;
		Node next;
	}
	public static void main(String[] args)
	{
	}
	
	public void add(Item item)
	{
		//向表尾添加元素
		Node oldlast = last;
		last = new Node();
		last.item = item;
		last.next = null;
		if(isEmpty()) 
			first = last;
		else
			oldlast.next = last;
		N++;
	}
	
	
	public Node KeyFind(int k)
	{
		//找到第k个结点（从零开始）并返回该节点
		Node p = first;
		if(k&gt;N||k&lt;0)
			return null;
		else
		{
			for(int i=0; i&lt;k; i++)
			{
				p = p.next;
			}
			return p;
		}
	}
	
	public boolean delete(int k)
	{
		//删除第k个结点（从零开始）
		if(k&gt;N||k&lt;0)
			return false;
		
		if(k==0)
		{
			first = first.next;
			if(isEmpty())
				last = null;
			N--;
		}
		else
		{
			Node delNode = KeyFind(k-1);
			if(k==N-1)
			{
				last = delNode;
				delNode.next = null;
			}
			else
			{
				delNode.next = delNode.next.next;
			}
		}
		return true;
	}

	
	public boolean isEmpty()	{return first == null;}
	public int size()				{return N;}
	@Override
	public Iterator&lt;Item&gt; iterator()
	{	return new ListIterator();	}
	private class ListIterator implements Iterator&lt;Item&gt;
	{
		private Node current = first;
		public boolean hasNext() {return current != null;}
		public void remove() {}
		public Item next()
		{
			Item item = current.item;
			current = current.next;
			return item;
		}
	}

}
</code></pre>
<p><mark>在表头插入</mark></p>
<pre><code>1-&gt;2-&gt;3-&gt;4-&gt;5
new temp//要插入的新节点
new oldfirst = first
first = temp
first.next = oldlast
N++
0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5
</code></pre>
<p><mark>在表尾插入</mark></p>
<pre><code>1-&gt;2-&gt;3-&gt;4-&gt;5
new temp//要插入的节点
new oldlast = last
last = new temp
last.next = null
if(isEmpty())
	first = last
else
	oldlast.next = last
N++
1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6
</code></pre>
<p><mark>从表头删除</mark></p>
<pre><code>1-&gt;2-&gt;3-&gt;4
first = first.next
N--
2-&gt;3-&gt;4
</code></pre>
<p><mark>从表尾删除</mark></p>
<pre><code>1-&gt;2-&gt;3-&gt;4
temp = first
for(int i = 0; i&lt;N; i++)
{	temp = temp.next
	if(temp.next == null)
	{
    	temp = null
    	break
    }
}
N--
1-&gt;2-&gt;3
</code></pre>
<p><mark>插入元素</mark></p>
<pre><code>1-&gt;2-&gt;3-&gt;4
//在2/3之间插入5
new node = 5
temp = first
for(;;)
{
	temp = temp.next
	if(temp == 2)
	{
		t = temp.next
		temp.next = 5
		5.next = t
		break
	}
}
N++
1-&gt;2-&gt;5-&gt;3-&gt;4
</code></pre>
<p><mark>删除元素</mark></p>
<pre><code>1-&gt;2-&gt;3-&gt;4
//删除3
temp = first
for(;;)
{
	temp = temp.next
	if(temp == 2)
	{
		temp.next = temp.next.next
		break
	}
}
N--
1-&gt;2-&gt;4
</code></pre>
<p><mark>交换元素</mark></p>
<pre><code>😂这个难倒我了，我还得钻研钻研
</code></pre>
<h2 id="动态数组">动态数组</h2>
<h3 id="原理">原理</h3>
<p>选择使用数组意味着必须先知道最大容量，在JAVA中，数组一旦创建，大小是无法改变的🤐</p>
<p>所以基本思路是：有一个函数isFull()来判断数组是否满了，如果满了，我们就新建一个更大的数组，把我们的数组整个存到新的数组中，然后将原本的数组删除。</p>
<p>具体操作时，我们在加入元素后，判断是否满了，如果满了，我们就新建一个更大的数组（通常是两倍），然后整个地把数组复制到新数组中；删除元素时，判断数组是否已经被删得只剩下四分之一（通常是四分之一，绝对不能大于等于二分之一），如果是，就新建一个最大长度为原数组最大长度一半的数组，再迁移整个数组</p>
<h3 id="代码举例">代码举例</h3>
<pre><code class="language-java">import java.util.Iterator;

public class ResizingArrayStack&lt;Item&gt; implements Iterable&lt;Item&gt;
{
	private Item[] a = (Item[]) new Object[1];	//栈元素
	private int N = 0;							//元素数量
	public boolean isEmpty()
	{
		return N == 0;
	}
	public int size()
	{
		return 	N;
	}
	public void resize(int max)
	{
		//整个算法的精髓，将栈移动到一个大小为max的新数组
		Item[] temp = (Item[]) new Object[max];
		for(int i = 0; i &lt; N; i++)
			temp[i] = a[i];
		a = temp;
	}
    public void push(Item item)
    {
        if( N == a.length)
            resize(2*a.length);
        a[N++] = item;
    }
	public Item pop()
	{	
		Item item = a[--N];
        a[N] = null; 	//避免对象游离
        if(N &gt; 0 &amp;&amp; N == a.length/4)
            resize(a.length/2);
        return Item;
	}
    public Iterator&lt;Item&gt; iterator()
    {
    	return new ReverseArrayIterator();    
	}
    private class ReverseArrayIterator() implements Iterator&lt;Item&gt;
    {
        //支持先进后出的迭代器
        private int i = N;
        public boolean hasNext()
        {
            return i &gt; 0;
		}
        public Item next()
        {
            return a[--i];
        }
        public void remove()//必须要有的函数，因为实现了Iterator，必须重载，即使用不上
    }
}
</code></pre>
<h3 id="注意">注意</h3>
<p><strong>Java是不支持泛型数组的</strong>，原书评价：“专家们仍然在争论这一点。你可能也需要成为专家才能理解它！对于初学者，请先了解<strong>共变数组</strong>（<em>covariant array</em>）和<strong>类型擦除</strong>（<em>type erasure</em>）”。但是如果你读过《Java编程思想》，你会发现里边介绍了一种实现泛型数组的方法👍</p>
<pre><code>a = (Item[]) new Object[i];
</code></pre>
<h2 id="队列">队列🍟</h2>
<p>说实在话没啥好说的，毕竟刷题经历不够多，待我变得更强再补充吧😯</p>
<h3 id="代码举例-2">代码举例</h3>
<pre><code class="language-java">import java.util.Iterator;

//用链表实现的队列，可以入队出队、查询长度还有遍历，但是不能删除其中的元素也不能插队
public class LinkListQueue&lt;Item&gt; implements Iterable&lt;Item&gt; 
{
	private Node first;	//指向最早添加的结点的链接
	private Node last;	//指向最后添加的结点的链接
	private int N;		//队列中的元素数量
	
	private class Node
	{
		Item item;
		Node next;
	}
	
	public void enqueue(Item item)
	{
		//向表尾添加元素
		Node oldlast = last;
		last = new Node();
		last.item = item;
		last.next = null;
		if(isEmpty()) 
			first = last;
		else
			oldlast.next = last;
		N++;
	}
	
	public Item dequeue()
	{
		//从表头删除元素并将其返回
		Item item = first.item;
		first = first.next;
		if(isEmpty())
			last = null;
		N--;
		return item;
	}
	
	public static void main(String[] args)
	{
		LinkListQueue&lt;Integer&gt; a = new LinkListQueue&lt;Integer&gt;();
		a.enqueue(1);
		a.enqueue(2);
		a.enqueue(3);
		a.enqueue(4);
		for(Integer c : a)
			System.out.println(c);
	}

	@Override
	public Iterator&lt;Item&gt; iterator()
	{	return new ListIterator();	}
	private class ListIterator implements Iterator&lt;Item&gt;
	{
		private Node current = first;
		public boolean hasNext()
		{	return current != null;	}
		public void remove() {}//尽量不要使用这个方法
		public Item next()
		{
			Item item = current.item;
			current = current.next;
			return item;
		}
	}
	public boolean isEmpty()	{return first == null;}
	public int size()				{return N;}
	
}
</code></pre>
<h2 id="堆栈">堆栈🌭</h2>
<p>我也没啥好说的...</p>
<h3 id="代码举例-3">代码举例</h3>
<pre><code class="language-java">import java.util.Iterator;

//用链表实现的堆栈队列，可以出栈入栈、查询长度还有遍历，但是不能删除其中的元素也不能插入
public class LinkListStack&lt;Item&gt; implements Iterable&lt;Item&gt; 
{
	private Node first;	//指向最早添加的结点的链接
	private int N;		//队列中的元素数量
	
	private class Node
	{
		Item item;
		Node next;
	}
	
	public void push(Item item)
	{
		//向栈顶添加元素
		Node oldfirst = first;
		first = new Node();
		first.item = item;
		first.next = oldfirst;
		N++;
	}
	
	public Item pop()
	{
		//从栈顶删除元素并将其返回
		Item item = first.item;
		first = first.next;
		N--;
		return item;
	}
	
	public static void main(String[] args)
	{
		// TODO Auto-generated method stub
		LinkListStack&lt;Integer&gt; a = new LinkListStack&lt;Integer&gt;();
		a.push(1);
		a.push(2);
		a.push(3);
		a.push(4);
		for(Integer i : a)
			System.out.println(i);
	}

	@Override
	public Iterator&lt;Item&gt; iterator()
	{	return new ListIterator();	}
	private class ListIterator implements Iterator&lt;Item&gt;
	{
		private Node current = first;
		public boolean hasNext()
		{	return current != null;	}
		public void remove() {}//尽量不要使用这个方法
		public Item next()
		{
			Item item = current.item;
			current = current.next;
			return item;
		}
	}
	public boolean isEmpty()	{return first == null;}
	public int size()				{return N;}
	
}
</code></pre>
<h2 id="背包">背包🍿</h2>
<p>背包没有顺序，但是代码是死的，所以一定是确定的，因此，我们通常让背包顺序存放，<strong>仅仅是因为这样比较好实现</strong>，不要在乎</p>
<h3 id="代码举例-4">代码举例</h3>
<pre><code class="language-java">import java.util.Iterator;

public class Bag&lt;Item&gt; implements Iterable&lt;Item&gt;
{
	private Node first;
	private class Node
	{
		Item item;
		Node next;
	}
	public void add(Item item)
	{
		Node oldfirst = first;
		first = new Node();
		first.item = item;
		first.next = oldfirst;
	}
	public Iterator&lt;Item&gt; iterator()
	{
		return new ListIterator();
	}
	private class ListIterator implements Iterator&lt;Item&gt;
	{
		private Node current = first;
		public boolean hasNext()
		{
			return current != null;
		}
		public void remove() {}
		public Item next()
		{
			Item item = current.item;
			current = current.next;
			return item;
		}
	}
	public static void main(String[] args)
	{
		// TODO Auto-generated method stub
		Bag&lt;Integer&gt; a = new Bag&lt;Integer&gt;();
		a.add(1);
		a.add(2);
		a.add(3);
		for(Integer i : a)
			System.out.println(i);
	}

}

</code></pre>
<h1 id="排序">排序</h1>
<p>所有的排序算法都是用在数组上，链表的排序之后会有更好的选择（链表排序Leetcode上是中等题😓）</p>
<h2 id="初级排序算法">初级排序算法</h2>
<h3 id="选择排序">选择排序🍕</h3>
<h4 id="原理-2">原理</h4>
<p>首先，找到数组中的最小元素，其次将他和数组中的第一个元素交换位置。再次，在剩下的元素中，找到最小的元素将它与数组第二个元素交换位置。如此反复，直到将整个数组排序，这种排序叫做选择排序，它在<strong>不断选则剩余元素中的最小者</strong></p>
<p>它有两个鲜明特点：</p>
<p><strong>运行时间与输入无关</strong>： 一个已经有序的数组和一个混乱的数组都要经历<mark>N次交换</mark>和<mark>N^2/2次比较</mark></p>
<p><strong>数据移动是最少的</strong>： 只移动了线性级别的次数</p>
<h4 id="代码举例-5">代码举例</h4>
<pre><code class="language-java">import java.util.Scanner;

public class Selection
{
	public static void sort(Comparable[] a)//指的是任何实现comparable的数组，包括Integer/Double/等等（但是不包括int/double）
	{
		//将a[]按升序排列
		int N = a.length;
		for(int i=0; i&lt;N; i++)
		{
			//将a[i]和a[i+1..N]中最小的元素交换
			int min = i;//最小元素的索引
			for(int j = i+1; j&lt;N; j++)
				if(less(a[j],a[min]))
					min = j;//找到未排序序列中的最小元素
			exch(a,i,min);
		}
	}
	
	private static boolean less(Comparable v, Comparable w)
	{	return v.compareTo(w) &lt; 0;	}
	private static void exch(Comparable[] a, int i, int j)
	{	Comparable t = a[i]; a[i] = a[j]; a[j] = t;	}
	private static void show(Comparable[] a)
	{
		//在单行中打印数组
		for(int i = 0; i&lt;a.length; i++)
			System.out.print(a[i]+&quot; &quot;);
	}
	public static boolean isSorted(Comparable[] a)
	{
		//测试数组元素是否有序
		for (int i=0; i&lt;a.length; i++)
			if(less(a[i],a[i-1]))	return false;
		return true;
	}
	
	public static void main(String[] args)
	{
		Integer[] a = new Integer[10];
		Scanner input = new Scanner(System.in);
		for(int i = 0; i&lt;10; i++)
			a[i] = input.nextInt();
		for(int i = 0; i&lt;10; i++)
			System.out.println(a[i]);
		System.out.println(&quot;now let's sort it&quot;);
		Selection.sort(a);
		for(Integer i : a)
			System.out.println(i);
	}

}
</code></pre>
<h3 id="插入排序">插入排序🍔</h3>
<h4 id="原理-3">原理</h4>
<p>将每一个元素插入到<strong>其他已经有序</strong>的元素中的适当位置，为了给要插入的元素腾出空间我们需要将其余所有元素在插入之前都向右移动一位，这就是插入排序。</p>
<p>和选择排序不同的是，插入排序所需时间取决于输入中元素的初始顺序。</p>
<p><strong>但是</strong>原理中插入元素时，要把其余元素右移一位，<strong>很显然这对于数组来说是很困难的</strong>，这里的一个取巧方案就是：选择第二个元素为<strong>索引</strong>，让它从左到右移动，每移动一格，<strong>就对索引左边元素进行一次冒泡排序</strong>，使新加入索引左边的元素能放在合适的位置</p>
<p>选择排序有一个特点，使它具有重要的意义</p>
<p>形如 2 1 4 3 6 5 8 7 10 9的数组 其中1-2，3-4.....成为一对<strong>倒置</strong></p>
<p>当数组中倒置<strong>小于数组大小的某个倍数（11，22，33....)</strong>，那么这个数组就是<mark>部分有序的数组</mark></p>
<p><strong>选择排序对于部分有序数组很有效</strong></p>
<h4 id="代码举例-6">代码举例</h4>
<pre><code class="language-java">import java.util.Scanner;

public class Insertion
{
	public static void sort(Comparable[] a)
	{
		//将a[]按升序排序
		int N = a.length;
		for(int i=1; i&lt;N; i++)
		{	//第一个元素已经排好
			//将未排序的元素一个一个插入已排好的部分中
			for(int j = i; j&gt;0 &amp;&amp; less(a[j],a[j-1]); j--)
				exch(a, j, j-1);//在a[]中找到合适的位置插入并将后边的元素往后移
			//这一步不是很好理解，可以试着自己画一画
		}
	}


	private static boolean less(Comparable v, Comparable w)
	{	return v.compareTo(w) &lt; 0;	}
	private static void exch(Comparable[] a, int i, int j)
	{	Comparable t = a[i]; a[i] = a[j]; a[j] = t;	}
	private static void show(Comparable[] a)
	{
		//在单行中打印数组
		for(int i = 0; i&lt;a.length; i++)
			System.out.print(a[i]+&quot; &quot;);
	}
	public static void main(String[] argvs)
	{
		Integer[] a = new Integer[10];
		Scanner input = new Scanner(System.in);
		for(int i = 0; i&lt;10; i++)
			a[i] = input.nextInt();
		for(int i = 0; i&lt;10; i++)
			System.out.println(a[i]);
		System.out.println(&quot;now let's sort it&quot;);
		Insertion.sort(a);
		for(Integer i : a)
			System.out.println(i);
	}
	
}
</code></pre>
<h3 id="希尔排序">希尔排序🥓</h3>
<p>基于插入排序的一种算法，性能优越，但人们仍未能确定它的确切性能</p>
<p>有经验的程序员有时会选择希尔排序，因为对于中等大小的数组它的运行时间是可以接受的，且代码量很小，还不需要使用额外的内存空间</p>
<p><s>更有经验的程序员用.sort</s></p>
<h4 id="原理-4">原理</h4>
<p>希尔排序的中心思想就是：使数组中<strong>任意间隔为h</strong>的元素都是有序的，称之为<strong>h有序数组</strong>，可以证明，<mark>如果h是以1结尾</mark>（<em>注意，h是一个数列，以1结尾意味着最后h总会为1</em>），我们都有能将这个h数组排好。</p>
<p>实现希尔排序的一种做法是，对于每个h，用插入排序将h个子数组独立地排序。但因为各个子数组相互独立，一种更简单的方法是 在h-子数组中将每个元素交换到比他大的元素之前去（将比它大的元素向右移动一格）。只需在插入排序的代码中将移动的元素的距离由1改为h即可。</p>
<p>我们在实现使，h不是不变的，h是一个递增的数列，这次我们使用<mark>h = 1/2((3^k) - 1)</mark>  为什么要选择这个数组？很难回答，这涉及到希尔排序复杂的数学性质 。</p>
<p>接下来说说具体实现步骤</p>
<ol>
<li>知道需要排序的数组的长度N</li>
<li>h = 1/2((3^k) - 1)</li>
<li>求出小于N/3的最大h</li>
<li>进行距离为h的插入排序</li>
<li>h = h/3</li>
<li>再次排序...</li>
<li>h = 1是最后一次排序</li>
</ol>
<h4 id="代码举例-7">代码举例</h4>
<pre><code class="language-java">import java.util.Random;

public class Shell
{
	public static void sort(Comparable[] a)
	{
		//将a[]按升序排列
		int N = a.length;
		int h = 1;
		while(h &lt; N/3)
			h = 3*h + 1;//h有1,4,13,40,121,364,1093...//注意，这个序列不一定是最好的，但已经够用
        //值得一提 h = 3*h +1是 h = 1/2((3^k) - 1)的递归形式
		while(h&gt;=1)
		{
			//将数组变为h有序
			for(int i=h; i&lt;N; i++)
			{
				//插入排序外循环
				for(int j=i; j&gt;=h &amp;&amp; less(a[j],a[j-1]); j-=h)
					exch(a, j, j-h);
			}	
			h = h/3;//间隔会越来越小，知道h为1时排好
		}
	}
	private static boolean less(Comparable v, Comparable w)
	{	return v.compareTo(w) &lt; 0;	}
	private static void exch(Comparable[] a, int i, int j)
	{	Comparable t = a[i]; a[i] = a[j]; a[j] = t;	}
	private static void show(Comparable[] a)
	{
		//在单行中打印数组
		for(int i = 0; i&lt;a.length; i++)
			System.out.print(a[i]+&quot; &quot;);
	}

	
	public static void main(String[] args)
	{
		// TODO Auto-generated method stub
		Random r = new Random(1);
		Integer[] a = new Integer[100];
		for (int i = 0; i&lt;a.length; i++)
		{
			a[i] = r.nextInt()%1000;
		}
		for(Integer i : a)
			System.out.println(i);
		System.out.println(&quot;now let's sort it!&quot;);
		Shell.sort(a);
		for(Integer i : a)
			System.out.println(i);
	}

}
</code></pre>
<h2 id="归并排序">归并排序</h2>
<p>一种优雅的递归算法，它能保证将任意长度为N的数组排序所需的时间和NlogN成正比，缺点也很明显，它所需要的<em>额外</em>空间和N成正比</p>
<h3 id="原地归并的抽象方法">原地归并的抽象方法🍳</h3>
<p>整个归并排序的核心😱</p>
<h4 id="原理-5">原理</h4>
<p>它的原理很简单</p>
<ol>
<li>将要归并的数组复制到一个新数组</li>
<li>将复制的数组分成两份</li>
<li>分成两份后，每个数组的开头都有一个索引，原数组也有一个索引</li>
<li>接下来将两个数组索引所指的元素进行比较</li>
<li>比较后，把小的那个元素放到原来的数组的索引的位置（也即是开头）</li>
<li>然后小的那个元素所在的数组的索引加1，即往右走，原数组的索引也加1</li>
<li>一直重复，会有几种结束的情况：左半边取尽（解决方法就是之后一直取右半边元素），右半边取尽（与前者相反），原数组索引走到尽头（结束）</li>
</ol>
<p>但值得注意的是，我们仅仅是进行了<em>归并</em>这个操作，意味着两个数组的左边元素总小于右边元素，但不意味着它已经有序了</p>
<p>####代码举例</p>
<pre><code class="language-java">public static void merge(Comparable[] a, int lo, int mid, int hi)
	{
		//整个归并排序的灵魂，将两个数组原地归并
		int i = lo, j = mid+1;
		
		for(int k=lo; k &lt;= hi; k++)//将a[lo..hi]整个复制到aux[lo...hi]
			aux[k] = a[k];
		for(int k=lo; k &lt;= hi; k++)//有两个游标 i j,分别对应左边和右边
			if		(i &gt; mid)				a[k] = aux[j++];//左半边已经没有元素了
			else if (j &gt; hi )				a[k] = aux[i++];//右半边已经没有元素了
			else if (less(aux[j], aux[i]))	a[k] = aux[j++];//左半边当前值大于右半边当前值
			else 							a[k] = aux[i++];//右半边当前值大于左半边当前值
	}
</code></pre>
<h3 id="自顶向下的归并排序">自顶向下的归并排序🥞</h3>
<p>本算法基于<strong>原地归并的抽象方法</strong>实现了另一种归并排序，这也是应用高效算法设计中<strong>分治思想</strong>的最典型的一个例子</p>
<h4 id="原理-6">原理</h4>
<p>实现上，相当于，先<strong>递归地</strong>把数组从中间分开，1变2，2变4，4变8....直到每个数组只有一个元素，然后再通过原地归并，<strong>递归地</strong>将数组归并，因为我们再分开数组的阶段已经递归了，因此归并使不必再递归（因为递归地实现 把数组分开 这个操作本身的“返回”必然是递归的，可以利用这个“返回”的递归）</p>
<p>要理解归并排序就要了解这里的<strong>递归</strong>究竟是如何实现的</p>
<figure data-type="image" tabindex="1"><img src="C:%5CUsers%5CAdministrator%5CDesktop%5C834468-20161016231421733-1908940953.png" alt="" loading="lazy"></figure>
<h4 id="代码举例-8">代码举例</h4>
<pre><code>import java.util.Random;

//自顶向下的归并排序
public class MergeUD
{
	private static Comparable[] aux;
	
	public static void sort(Comparable[] a)
	{
		aux = new Comparable[a.length];//一次性分配空间
		sort(a, 0, a.length -1);
	}
	
	private static void sort(Comparable[] a, int lo, int hi)
	{
		//将数组a[lo...hi]排序（递归地
		if(hi &lt;= lo) return;
		int mid = lo + (hi - lo) /2;
		sort(a, lo, mid);//排序左半边
		sort(a, mid+1, hi);//排序右半边
		merge(a, lo, mid, hi);//归并结果
	}
	public static void merge(Comparable[] a, int lo, int mid, int hi)
	{
		//整个归并排序的灵魂，将两个数组原地归并
		int i = lo, j = mid+1;
		
		for(int k=lo; k &lt;= hi; k++)//将a[lo..hi]整个复制到aux[lo...hi]
			aux[k] = a[k];
		for(int k=lo; k &lt;= hi; k++)//有两个游标 i j,分别对应左边和右边
			if		(i &gt; mid)				a[k] = aux[j++];//左半边已经没有元素了
			else if (j &gt; hi )				a[k] = aux[i++];//右半边已经没有元素了
			else if (less(aux[j], aux[i]))	a[k] = aux[j++];//左半边当前值大于右半边当前值
			else 							a[k] = aux[i++];//右半边当前值大于左半边当前值
	}
	public static void main(String[] args)
	{
		// TODO Auto-generated method stub
		Random r = new Random(1);
		Integer[] a = new Integer[10];
		for (int i = 0; i&lt;a.length; i++)
		{
			a[i] = r.nextInt()%10;
		}
		for(Integer i : a)
			System.out.println(i);
		System.out.println(&quot;now let's sort it!&quot;);
		MergeUD.sort(a);
		for(Integer i : a)
			System.out.println(i);
	}
	private static boolean less(Comparable v, Comparable w)
	{	return v.compareTo(w) &lt; 0;	}
	private static void exch(Comparable[] a, int i, int j)
	{	Comparable t = a[i]; a[i] = a[j]; a[j] = t;	}
	private static void show(Comparable[] a)
	{
		//在单行中打印数组
		for(int i = 0; i&lt;a.length; i++)
			System.out.print(a[i]+&quot; &quot;);
	}
	public static boolean isSorted(Comparable[] a)
	{
		//测试数组元素是否有序
		for (int i=0; i&lt;a.length; i++)
			if(less(a[i],a[i-1]))	return false;
		return true;
	}
	
}
</code></pre>
<p>###自底向上的归并排序🍞</p>
<p>自顶向上归并是将大问题分解成许多小问题，然后通过解决这些小问题来解决整个大问题，尽管我们考虑的问题是归并两个大数组，实际上我们归并的数组大多数都非常小。</p>
<h4 id="原理-7">原理</h4>
<p>实现归并排序的另一种方法是先归并那些微型数组，然后再成对归并得到的子数组，如此这般，直到我们将整个数组归并在一起。这种实现方法比标准递归方法所需的代码量更少。首先进行一个一个元素的归并，然后两个两个元素的归并，然后四个四个元素的归并....</p>
<figure data-type="image" tabindex="2"><img src="C:%5CUsers%5CAdministrator%5CDesktop%5C%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A.png" alt="" loading="lazy"></figure>
<h4 id="代码举例-9">代码举例</h4>
<pre><code class="language-java">import java.util.Random;

//自底向上的归并排序
public class MergeDU
{
	private static Comparable[] aux;  //辅助数组
	
	public static void sort(Comparable[] a)
	{
		//进行lgN次两两归并;
		int N = a.length;
		aux = new Comparable[N];
		for(int sz=1; sz&lt;N; sz=sz+sz) //sz是每个子数组大小
			for(int lo=0; lo&lt;N-sz; lo=lo+sz+sz)//lo：子数组索引
				merge(a, lo, lo+sz-1, Math.min(lo+sz+sz-1, N-1));
	}
	public static void merge(Comparable[] a, int lo, int mid, int hi)
	{
		//整个归并排序的灵魂，将两个数组原地归并
		int i = lo, j = mid+1;
		
		for(int k=lo; k &lt;= hi; k++)//将a[lo..hi]整个复制到aux[lo...hi]
			aux[k] = a[k];
		for(int k=lo; k &lt;= hi; k++)//有两个游标 i j,分别对应左边和右边
			if		(i &gt; mid)				a[k] = aux[j++];//左半边已经没有元素了
			else if (j &gt; hi )				a[k] = aux[i++];//右半边已经没有元素了
			else if (less(aux[j], aux[i]))	a[k] = aux[j++];//左半边当前值大于右半边当前值
			else 							a[k] = aux[i++];//右半边当前值大于左半边当前值
	}
	public static void main(String[] args)
	{
		Random r = new Random(1);
		Integer[] a = new Integer[100];
		for (int i = 0; i&lt;a.length; i++)
		{
			a[i] = r.nextInt()%1000;
		}
		for(Integer i : a)
			System.out.println(i);
		System.out.println(&quot;now let's sort it!&quot;);
		MergeDU.sort(a);
		for(Integer i : a)
			System.out.println(i);
	}
	
	private static boolean less(Comparable v, Comparable w)
	{	return v.compareTo(w) &lt; 0;	}
	private static void exch(Comparable[] a, int i, int j)
	{	Comparable t = a[i]; a[i] = a[j]; a[j] = t;	}
	private static void show(Comparable[] a)
	{
		//在单行中打印数组
		for(int i = 0; i&lt;a.length; i++)
			System.out.print(a[i]+&quot; &quot;);
	}
	public static boolean isSorted(Comparable[] a)
	{
		//测试数组元素是否有序
		for (int i=0; i&lt;a.length; i++)
			if(less(a[i],a[i-1]))	return false;
		return true;
	}
}
</code></pre>
<h4 id="链表的排序">链表的排序</h4>
<p>值得一提的是，自底向上的归并排序非常适合于用链表组织的数据，然鹅，我不会😭，再努努力吧...</p>
<h2 id="快速排序">快速排序</h2>
<p>快速排序可能是应用最广泛的排序算法了。快速排序流行的原因是它实现简单，适用于各种不同输入数据且在一般应用中<mark>比其他排序算法都要快得多</mark>。</p>
<p>快排一个引人注目的特点包括 <mark>它是原地排序</mark>（只需要一个很小的辅助栈），且将长度为N的的数组排序所需的时间和NlgN成正比。<mark>我们之前学过的任何算法都无法将这两个优点结合起来</mark>。它的缺点也很明显  <mark>极度的脆弱</mark>。实现时要非常小心才能避免低劣的性能。</p>
<h3 id="基本快速排序">基本快速排序🥐</h3>
<p>快速排序是一种<strong>分治的</strong>排序算法，它将一个数组分为两个子数组，将两部分独立地排序。</p>
<p>快排与归并是互补的：</p>
<ol>
<li>
<p>归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序</p>
</li>
<li>
<p>快速排序是当两个子数组都有序时自然整个数组都有有序了</p>
</li>
</ol>
<p>在了解快速排序的具体实现之前，有一个重要的概念 <strong>切分</strong>，切分会将a[j]元素放在数组中合适的位置，这个位置满足a[j]左边的元素都比a[j]小，a[j]右边的元素都比a[j]大，当我们递归地调用切分，可以很显然得到，整个数组都会被排好。</p>
<p>那么切分该如何实现呢😐</p>
<h4 id="原理-8">原理</h4>
<p>通常我们选择第一个元素作切分元素，然后将小于这个切分元素的放数组左边，大于这个切分元素的放右边，然后<strong>递归地</strong>再将左边的数组和右边的数组分别进行切分。那么，怎样把这些元素放到切分元素的两边呢？</p>
<ol>
<li>
<p>先选定<em>切分元素</em>，这里我们选择<mark>数组的第一个元素</mark></p>
</li>
<li>
<p>一个索引指向切分元素右边第一个元素（也就是数组的第二个元素），一个指向数组最右边</p>
</li>
<li>
<p>左索引向右一直扫描，找到比切分元素大的元素时停止</p>
</li>
<li>
<p>右索引向左一直扫描，找到比切分元素大的元素时停止</p>
</li>
<li>
<p>交换左右索引上的元素</p>
</li>
<li>
<p>然后各索引继续，以当前位置为起点，继续上述操作，直到两个索引相遇</p>
</li>
<li>
<p>最后，别忘了切分元素还放在数组第一位，这时我们要把它放到合适的位置</p>
</li>
<li>
<p>可以证明，索引相遇的地方就是切分元素应该待的地方，所以交换第一个元素与索引相遇的地方的元素</p>
</li>
</ol>
<p>这样，我们便完成了一次<strong>切分</strong>，接下来我们应该<strong>递归地</strong>对左右两边数组再次进行切分</p>
<h4 id="代码举例-10">代码举例</h4>
<pre><code class="language-java">import java.util.Random;

public class Quick
{
	public static void sort(Comparable[] a)
	{
		sort(a, 0, a.length -1);
	}
	private static void sort(Comparable[] a, int lo, int hi)
	{
		//标准的快速排序
		if(hi &lt;= lo)
			return;
		int j = partition(a, lo, hi);//切分，快排的关键点
		sort(a, lo, j-1);//对左边排序
		sort(a, j+1, hi);//对右边排序
	}
	private static int partition(Comparable[] a, int lo, int hi)
	{
		int i = lo, j = hi + 1;//左指针与右指针
		Comparable v = a[lo];  //切分元素
		while(true)
		{
			while(less(a[++i], v) )
				if(i == hi) break;
			//从左到右扫描找出第一个大于切分元素的单元
			while(less(v, a[--j]) )
				if(j == lo) break;
			//从右到左扫描找出第一个小于切分元素的单元
				
			if(i &gt;= j) break;
			exch(a, i, j);//交换两个单元
		}
		//注意此时切分元素仍然放在第一个位置，因此下一步要把它放到中间，而i,j已经在中间相遇，所以放在j处
		exch(a, lo, j);//将v = a[j]放入正确的位置
		return j;
	}
	private static boolean less(Comparable v, Comparable w)
	{	return v.compareTo(w) &lt; 0;	}
	private static void exch(Comparable[] a, int i, int j)
	{	Comparable t = a[i]; a[i] = a[j]; a[j] = t;	}
	private static void show(Comparable[] a)
	{
		//在单行中打印数组
		for(int i = 0; i&lt;a.length; i++)
			System.out.print(a[i]+&quot; &quot;);
	}
	public static boolean isSorted(Comparable[] a)
	{
		//测试数组元素是否有序
		for (int i=0; i&lt;a.length; i++)
			if(less(a[i],a[i-1]))	return false;
		return true;
	}
	
	public static void main(String[] args)
	{
		Random r = new Random(1);
		Integer[] a = new Integer[100];
		for (int i = 0; i&lt;a.length; i++)
		{
			a[i] = r.nextInt()%1000;
		}
		for(Integer i : a)
			System.out.println(i);
		System.out.println(&quot;now let's sort it!&quot;);
		Quick.sort(a);
		for(Integer i : a)
			System.out.println(i);

	}

}
</code></pre>
<h4 id="注意-2">注意</h4>
<p>对于小数组来说，快速排序比插入排序满，并且，因为递归，快速排序的sort()方法在小数组中也会调用自己</p>
<p>因此，在排序小数组时应该切换到插入排序。因此，可以对代码进行简单修改</p>
<pre><code>if(hi &lt;= lo )
	return;
</code></pre>
<p>变成</p>
<pre><code>if(hi &lt;= lo + M)
{
	Insertion.sort(a, lo, hi);
	return;
}
</code></pre>
<h3 id="三向切分快速排序">三向切分快速排序🥨</h3>
<p>我们的快速排序性能已经很好了，可是还有巨大的改进空间。例如，一个完全重复的子数组就不需要排序了，但我们的算法仍然会对它进行切分。所以，为了解决那些有大量重复元素的数组，我们选择一种名为<strong>三向切分</strong>的算法，又叫<strong>熵最优快速排序</strong>。</p>
<h4 id="原理-9">原理</h4>
<p>所谓<em>三向切分</em>，就是不同于普通的快排，只是分为左右两边数组，三向切分会把数组分为 <strong>左边 小； 中间 一样；右边 大</strong>。但是它的实现困扰了许多计算机学家。这里我们选择<strong>Dijkstra</strong>的切分方法。</p>
<p>这里的实现，我们选择使用Comparable接口(而不是less())对a[i]进行三向比较。</p>
<ol>
<li>
<p>我们维护四个索引 lo, hi, lt, gt, i</p>
</li>
<li>
<p>选取数组第一个元素<strong>v</strong>为切分元素</p>
</li>
<li>
<p>lo与lt索引指向数组第一个元素</p>
</li>
<li>
<p>i指向数组第二个元素</p>
</li>
<li>
<p>hi与gt索引指向数组最后一个元素</p>
</li>
<li>
<p>让i所指的元素和切分元素比较</p>
</li>
<li>
<p>如果<strong>a[i]小于v</strong>，交换a[lt]和a[i]，并将i和lt向右移动一格</p>
</li>
<li>
<p>如果<strong>a[i]大于v</strong>，交换a[gt]和a[i]，并将gt向左移动一格</p>
</li>
<li>
<p>如果<strong>a[i]等于v</strong></p>
</li>
<li>
<p>一直重复6-&gt;9(7,8,9是互斥事件)，直到i遇见gt</p>
</li>
<li>
<p>这样我们就已经完成了一次三向切分</p>
</li>
<li>
<p>对左边和右边的元素再次<strong>递归地</strong>实现上面的过程，中间的元素可以不用动了</p>
</li>
</ol>
<h4 id="代码举例-11">代码举例</h4>
<pre><code class="language-java">import java.util.Random;

public class Quick
{
	public static void sort(Comparable[] a)
	{
		sort3way(a, 0, a.length -1);
	}
	private static void sort3way(Comparable[] a, int lo, int hi)
	{
		//三切分快速排序，用来处理数据中有相同元素的数组的排序
		if(hi &lt;= lo)
			return;
		int lt = lo, i = lo + 1, gt = hi;
		Comparable v = a[lo];
		while(i &lt;= gt)
		{
			int cmp = a[i].compareTo(v);
			if		(cmp &lt; 0)
				exch(a, lt++, i++);//放左边
			else if (cmp &gt; 0)
				exch(a, i, gt--);//放右边
			else
				i++;//留在原地，之后它就是在中间
		}//这个循环实现了a[lo..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..hi]
		sort3way(a, lo, lt - 1);
		sort3way(a, gt + 1, hi);
	}
	private static boolean less(Comparable v, Comparable w)
	{	return v.compareTo(w) &lt; 0;	}
	private static void exch(Comparable[] a, int i, int j)
	{	Comparable t = a[i]; a[i] = a[j]; a[j] = t;	}
	private static void show(Comparable[] a)
	{
		//在单行中打印数组
		for(int i = 0; i&lt;a.length; i++)
			System.out.print(a[i]+&quot; &quot;);
	}
	public static boolean isSorted(Comparable[] a)
	{
		//测试数组元素是否有序
		for (int i=0; i&lt;a.length; i++)
			if(less(a[i],a[i-1]))	return false;
		return true;
	}
	
	public static void main(String[] args)
	{
		Random r = new Random(1);
		Integer[] a = new Integer[100];
		for (int i = 0; i&lt;a.length; i++)
		{
			a[i] = r.nextInt()%1000;
		}
		for(Integer i : a)
			System.out.println(i);
		System.out.println(&quot;now let's sort it!&quot;);
		Quick.sort(a);
		for(Integer i : a)
			System.out.println(i);

	}

}
</code></pre>
<h2 id="优先队列">优先队列</h2>
<p>很多情况下，我们需要这么一种工具，它能非常快速地提供给我们一个数组中最大的元素(最小同理)。很显然，一种简单粗暴的解决方式就是在取出元素时排序整个数组，但是这样太慢了，因为我们只是要最大的，此时数组不一定要有序，因此我们引入一种工具：<strong>优先队列</strong></p>
<h3 id="二叉堆优先队列">二叉堆优先队列🥖</h3>
<p>这里我们只介绍二叉堆组成的优先队列，在最坏情况下，它能保证将元素插入或取出优先队列都只需要<strong>logN</strong>的复杂度，实现整体最优。👍</p>
<h4 id="原理-10">原理</h4>
<p><strong>二叉堆</strong>的定义</p>
<ol>
<li>
<p>当一棵二叉树的每个节点都大于等于(小于等于同理)它的两个子节点时，它被称为<strong>堆有序</strong></p>
</li>
<li>
<p>根节点是堆有序的二叉树的最值节点</p>
</li>
<li>
<p><strong>二叉堆</strong>是一组能够用<strong>堆有序</strong>的<strong>完全二叉树</strong>（你不会不知道什么是完全二叉树吧）排序的元素，并在数组中按层级储存</p>
</li>
<li>
<p>为了方便，<strong>我们不使用第一个节点</strong>，这样，位置为k的<strong>父节点的位置为k/2</strong>，两个<strong>子节点分别是2k或2k+1</strong></p>
</li>
</ol>
<figure data-type="image" tabindex="3"><img src="C:%5CUsers%5CAdministrator%5CDesktop%5C%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%5C77c6a7efce1b9d16836da71efbdeb48f8c546422.png" alt="" loading="lazy"></figure>
<p>堆有两个基本操作，<strong>插入元素</strong>，<strong>删除最值元素</strong></p>
<p><strong>插入元素</strong>：我们将新元素加到数组末尾，然后增加堆的大小N，并让这个元素<strong>上浮</strong>到合适位置</p>
<p><strong>删除最值元素</strong>：将数组顶端元素删去最大的元素并返回，然后<strong>把数组最后一个元素放到顶端</strong>，让这个元素<strong>下沉</strong>到合适位置</p>
<p>我们所说的<strong>上浮</strong>与<strong>下沉</strong>指的是<strong>堆的有序化</strong>，即将元素放到它应在在的位置</p>
<p><strong>上浮</strong>：如果堆的有序状态因为某个节点<strong>变得比它的父节点更大</strong>而被打破，那么我们就需要<strong>交换它和它的父节点</strong>来修复堆。很显然，交换后，这个节点比它的两个子节点更大，<strong>但这个节点仍然可能比它现在的父节点大</strong>，因此我们要重复上面的操作，直到有序。</p>
<p><strong>下沉</strong>：如果堆的有序状态因为某个节点<strong>变得比它的两个子节点或者其中之一更小</strong>而被打破了，那么我们需要<strong>交换它和它的两个子节点中最大的那个</strong>来修复堆，不断重复上述操作，直到它的子节点都比它小或者到达了堆的底部。</p>
<h4 id="代码举例-12">代码举例</h4>
<p>值得一提的是，堆可以分为<strong>大顶堆</strong>和<strong>小顶堆</strong>，这里我们实现前者</p>
<pre><code class="language-java">import java.util.Random;
public class MaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt;
{
	//基于堆的优先队列
	private Key[] pq;	//基于堆的完全二叉树
	private int N = 0;	//储存于pq[1..N]中，pq[0]没有使用
	
	public MaxPQ(int maxN)
	{
		pq = (Key[]) new Comparable[maxN+1];
	}
	public boolean isEmpty()
	{
		return N == 0;
	}

	public void insert(Key v)
	{
		pq[++N] = v;
		swim(N);
	}
	public Key delMax()
	{
		Key max = pq[1];
		exch(1, N--);
		pq[N+1] = null;
		sink(1);
		return max;
	}
	
	private boolean less(int i, int j)
	{
		return pq[i].compareTo(pq[j]) &lt; 0;
	}
	private void exch(int i, int j)
	{
		Key t = pq[i];
		pq[i] = pq[j];
		pq[j] = t;
	}
	private void swim(int k)//上浮
	{
		while(k&gt;1 &amp;&amp; less(k/2, k))
		{
			exch(k/2, k);
			k = k/2;
		}
	}
	private void sink(int k)
	{
		while(2*k &lt;= N)
		{
			int j = 2*k;
			if(j&lt;N &amp;&amp; less(j, j+1))
				j++;//确定两个子节点哪个更大
			if(!less(k, j))
				break;//再比较最大的子节点与父节点的关系
			exch(k, j);
			k = j;
		}
	}
	
	public static void main(String[] args)
	{
		// TODO Auto-generated method stub
		MaxPQ&lt;Integer&gt; a = new MaxPQ(1000000);
		Random r = new Random(13);
		for (int i = 0; i&lt;1000000; i++)
		{
			a.insert(r.nextInt()%1000000);
		}
		System.out.println(a.delMax());
	}

}

</code></pre>
<h3 id="堆排序">堆排序🧀</h3>
<p>如果将所有元素插入一个小顶堆，然后重复调用<strong>删除最小元素</strong>的操作来将它们按顺序删去。这就是堆排序。</p>
<h4 id="原理-11">原理</h4>
<p>堆排序有两个阶段 <strong>堆的构造</strong>，<strong>下沉排序</strong>。</p>
<p><strong>堆的构造</strong>：我们将原始数组重新组织安排进一个堆中。一个无脑的方法，即从左到右遍历数组，对每个元素都进行上浮操作，这样能在NlogN内实现。可是这样<strong>太笨了</strong>😫  一种更聪明更高效的方法是 ：<strong>从N/2开始向左对数组中的元素进行下沉</strong>，为什么要这么做呢？因为由于<strong>完全二叉树</strong>的数学性质，可以发现，N/2之后的所有元素都是<strong>叶</strong>，显然，叶是不需要下沉的，所以我们只用下沉N/2之前的元素。</p>
<p><strong>下沉排序</strong>：我们从堆中按<strong>递减顺序</strong>取出所有元素并得到排序结果。具体来说，我们将数组第一个元素(数组[0]是不用的，所以第一个元素是数组[1])<strong>与最后一个元素交换，然后下沉交换后的第一个元素</strong>。(与选择排序相似,但所需的比较少得多)</p>
<h4 id="代码举例-13">代码举例</h4>
<pre><code class="language-java">public class PQsort
{
	public static void sort(Comparable[] a)
	{
		//堆排序
		int N = a.length;
		Comparable[] pb = new Comparable[N+1]; 
		for(int i=0; i&lt;N; i++)
			pb[i+1] = a[i];
		for(int k = N/2; k &gt;= 1; k--)
			sink(pb, k, N);//用于构造大顶堆
		while(N &gt; 1)
		{
			exch(pb, 1, N--);
			sink(pb, 1, N);
		}
		for(int i=0; i&lt;a.length; i++)
			a[i] = pb[i+1];
	}
	private static void sink(Comparable[] a, int k, int N)
	{
		while(2*k &lt;= N)
		{
			int j = 2*k;
			if(j&lt;N &amp;&amp; less(a, j, j+1))
				j++;
			if(!less(a, k, j))
				break;
			exch(a, k, j);
			k = j;
		}
	}
	private static boolean less(Comparable[] pq, int i, int j)
	{
		return pq[i].compareTo(pq[j]) &lt; 0;
	}
	private static void exch(Comparable[] pq, int i, int j)
	{
		Comparable t = pq[i];
		pq[i] = pq[j];
		pq[j] = t;
	}
	private static void show(Comparable[] a)
	{
		//在单行中打印数组
		for(int i = 0; i&lt;a.length; i++)
			System.out.print(a[i]+&quot; &quot;);
	}
	public static void main(String[] args)
	{
		Integer[] a = {19,15,18,20,5,24,1,13,16,12,5};
		sort(a);
		show(a);
	}

}
</code></pre>
<h3 id="索引优先队列">索引优先队列🥗</h3>
<p>我们的优先队列能做到的事情很少，只能向其中加入元素和获取并删除最值元素。然鹅在很多应用中，允许使用<mark>已经进入优先队列中的元素</mark>是很有必要的（如Dijkstra算法）。要做到这一点的一种简单方法就是给每个元素一个<strong>索引</strong>。</p>
<h4 id="原理-12">原理</h4>
<p>索引优先队列用一个<strong>整数</strong>和队列中的<strong>元素</strong>进行关联，这样，当我们要访问队列中的元素时，只需要用它所关联的整数进行索引查找就可以了。</p>
<p>为此，我们创立三个数组  pq，qp，elements</p>
<p>其中，pq[qp[i]] = qp[pq[i]] = i，这样，当我们想访问元素“b”时，我们就可以通过elements[10]来访问它（其中10是与&quot;b &quot;相关的整数），而当我们想要知道元素&quot;b&quot;在<strong>二叉堆</strong>中处于哪个位置时，我们可以通过qp[10]。到现在我们只用了两个数组(elements和qp)，那pq数组呢？</p>
<p>首先，作为优先队列的一种，它一定能通过<strong>上浮</strong>和<strong>下沉</strong>来使堆<strong>有序化</strong>。在普通优先队列中，我们直接对队列的元素进行操作，而在索引优先队中，<strong>储存元素的数组已经不再具有二叉堆的性质</strong>，取而代之的使pq数组，因此在索引优先队列中，<strong>储存元素的数组用来快速索引查找，pq数组作为储存元素的数组的映射，具有堆的性质，因此我们的上浮下沉都是对pq数组操作而不是对储存元素的数组</strong>。</p>
<p>当然，为了保持pq[qp[i]] = qp[pq[i]] = i的性质，我们在改变pq后也要相应改变qp</p>
<figure data-type="image" tabindex="4"><img src="https://shame41.github.io/post-images/1615888769947.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://shame41.github.io/post-images/1615888773668.jpg" alt="" loading="lazy"></figure>
<h4 id="代码举例-14">代码举例</h4>
<pre><code class="language-java">![u=2489824036,314288118&amp;fm=26&amp;gp=0](C:\Users\Administrator\Desktop\新建文件夹\u=2489824036,314288118&amp;fm=26&amp;gp=0.png)public class IndexMinPQ&lt;Key extends Comparable&lt;Key&gt;&gt;
{
	private int N;				//amount of the elements in PQ
	private int[] pq;			//index binary heap, begin at '1'
	private int[] qp;			//inverted pq : qp[pq[i]] = pq[qp[i]] = i
	private Key[] keys;			//elements with priority
	public IndexMinPQ(int maxN)
	{
		keys = (Key[]) new Comparable[maxN + 1];
		pq = new int[maxN + 1];
		qp = new int[maxN + 1];
		for(int i = 0; i &lt;= maxN; i++)
			qp[i] = -1;
	}
	private void exch(int i, int j)
	{
		int t = pq[i];
		pq[i] = pq[j];
		pq[j] = t;
		t = qp[pq[i]];
		qp[pq[i]] = qp[pq[j]];
		qp[pq[j]] = t;
	}
	private void swim(int k)//上浮
	{
		while(k&gt;1 &amp;&amp; less(k/2, k))
		{
			exch(k/2, k);
			k = k/2;
		}
	}
	private void sink(int k)
	{
		while(2*k &lt;= N)
		{
			int j = 2*k;
			if(j&lt;N &amp;&amp; less(j, j+1))
				j++;
			if(!less(k, j))
				break;
			exch(k, j);
			k = j;
		}
	}
	private boolean less(int i, int j)
	{
		return keys[pq[i]].compareTo(keys[pq[j]]) &gt; 0;
	}
	public boolean isEmpty()
	{
		return N == 0;
	}
	public boolean contains(int k)
	{
		return qp[k] != -1;
	}
	public void insert(int k, Key key)
	{
		N++;
		qp[k] = N;
		pq[N] = k;
		keys[k] = key;
		swim(N);
	}
	public Key min()
	{
		return keys[pq[1]];
	}
	public int delMin()
	{
		int indexOfMin = pq[1];
		exch(1, N--);
		sink(1);
		keys[pq[N+1]] = null;
		qp[pq[N+1]] = -1;
		return indexOfMin;
	}

	public int minIndex()
	{
		return pq[1];
	}
	public void change(int k, Key key)
	{
		keys[k] = key;
		swim(qp[k]);
		sink(qp[k]);
	}
	public void delete(int k)
	{
		int index = qp[k];
		exch(index, N--);
		swim(index);
		sink(index);
		keys[k] = null;
		qp[k] = -1;
	}
	public static void main(String[] args)
	{
		// TODO Auto-generated method stu
		IndexMinPQ&lt;Integer&gt; a = new IndexMinPQ&lt;Integer&gt;(10);
		a.insert(1,11);
		a.insert(3,6);
		a.insert(4,14);
		a.insert(6,3);
		a.insert(8,8);
		a.insert(10,2);
		a.delete(4);
		System.out.println(a.minIndex());
ercha
	}

}
</code></pre>
<p>#查找</p>
<p>现代计算机和网络使我们能够访问海量数组。高效检索这些信息的能力是处理它们的重要前提！</p>
<h2 id="二叉查找树">二叉查找树🥙</h2>
<p>首先，我们需要定义一些术语。我们所使用的数据结构是由<strong>结点</strong>组成（后边我总是时不时打错成“节点”，无伤大雅），结点包括的<strong>链接</strong>可以为空（null）或者指向其他节点。在一个<strong>二叉树</strong>中，每个结点只能有一个父结点（根节点没有父结点），而且每个结点都只有<em>左右</em>两个链接，指向自己的<em>左子结点</em>和<em>右子节点</em>。在二叉查找树中，每个结点还包含了一个<strong>键</strong>和一个<strong>值</strong>。</p>
<h3 id="构造">构造</h3>
<p>这里我们用链表来构造查找二叉树。私有方法size( )可以得到节点任意节点的子节点数</p>
<p>size(x) = size(x.left) + size(x.right) + 1</p>
<p><mark>二叉查找树(BST)是一棵二叉树，其中每个结点都有一个可比较的键，且每个结点的键都大于其左子树中任意节点的键而小于右子树中的任意节点的键</mark></p>
<figure data-type="image" tabindex="6"><img src="https://shame41.github.io/post-images/1615888748736.png" alt="" loading="lazy"></figure>
<h3 id="查找">查找</h3>
<p>查找一个键，如果键在树中那么一定能找到，成为<em>命中</em>，如果不在，则返回null。由于查找二叉树的完美结构，查找一个键时，比较这个键与根节点的大小，再根据二者的大小，选择接下来要与（左/右）节点比较，就这样<strong>递归地</strong>进行，直到二者相等，或者递归到了叶。</p>
<h3 id="插入">插入</h3>
<p>插入操作与查找操作相似。我们在插入时，先比较它与根节点的大小，如果比根节点大，那么<strong>就放在根节点的左边，否则放在根节点的右边</strong>（当然，如果和根节点相等，那就直接把根节点的值改成要插入的值）。这里的<em>放在左边或者右边</em>是递归的关键。这种递归进行到最后，要么遇到了一个和插入结点的键值相等的结点</p>
<p>，要么遇到子叶。如果遇到键值相等的节点，我们就可以把那个节点的值替换成我们要插入的结点的值。<strong>如果遇到了子叶，我们就创建一个新节点，让它的键和值等于我们要插入的结点的</strong>，这时，结点的父结点就是我们刚刚比较过的结点。</p>
<figure data-type="image" tabindex="7"><img src="https://shame41.github.io/post-images/1615888730218.gif" alt="" loading="lazy"></figure>
<h3 id="返回最值">返回最值</h3>
<p>很轻易就能发现，二叉查找树最左下角的结点是最小的结点，最右下角的结点是最大的结点。了解了这个，寻找最值也就转化成立寻找最左的子叶和最右的子叶。</p>
<h3 id="删除">删除</h3>
<p>BST的删除操作有些许复杂，它有三种情况：</p>
<ol>
<li>删除的结点是叶</li>
<li>删除的结点有一个子节点</li>
<li>删除的结点有两个子节点</li>
</ol>
<p>1962年，T.Hibbard提出了解决这个问题的第一种方法，删除节点x后用它的<em>后继节点</em>填上它的位置。</p>
<ol>
<li>如果结点是叶，那么就直接删除结点</li>
<li>如果结点没有右节点，那么删除节点后，让它的左子树填补上它的位置</li>
<li>如果结点有右节点，那么找到右子树中的<strong>最小结点</strong>，把它剔掉（即执行删除动作），然后放在要删除结点的位置（继承被删除的结点的父子关系）</li>
</ol>
<figure data-type="image" tabindex="8"><img src="https://shame41.github.io/post-images/1615888689422.png" alt="" loading="lazy"></figure>
<h3 id="遍历">遍历</h3>
<p>二叉树有三种遍历方法，<strong>前序遍历，中序遍历，后序遍历</strong></p>
<p>三者都是从根节点开始遍历，差别在于遍历</p>
<figure data-type="image" tabindex="9"><img src="https://shame41.github.io/post-images/1615888666460.gif" alt="" loading="lazy"></figure>
<h4 id="前序遍历">前序遍历</h4>
<p>前序遍历从当前节点（节点 c）开始访问，然后访问其左孩子，再访问右孩子。开始时，节点 c 为 BST 的根节点。算法如下：</p>
<ol>
<li>访问节点 c；</li>
<li>对节点 c 的左孩子重复第 1 步；</li>
<li>对节点 c 的右孩子重复第 1 步；</li>
</ol>
<p>则上图中树的遍历结果为：90, 50, 20, 5, 25, 75, 66, 80, 150, 95, 92, 111, 175, 166, 200。</p>
<h4 id="中序遍历">中序遍历</h4>
<p>中序遍历是从当前节点（节点 c）的左孩子开始访问，再访问当前节点，最后是其右节点。开始时，节点 c 为 BST 的根节点。算法如下：</p>
<ol>
<li>访问节点 c 的左孩子；</li>
<li>对节点 c 重复第 1 步；</li>
<li>对节点 c 的右孩子重复第 1 步。</li>
</ol>
<p>则上图中树的遍历结果为：5, 20, 25, 50, 66, 75, 80, 90, 92, 95, 111, 150, 166, 175, 200。</p>
<h4 id="后序遍历">后序遍历</h4>
<p>后序遍历首先从当前节点（节点 c）的左孩子开始访问，然后是右孩子，最后才是当前节点本身。开始时，节点 c 为 BST 的根节点。算法如下：</p>
<ol>
<li>访问节点 c 的左孩子；</li>
<li>对节点 c 的右孩子重复第1 步；</li>
<li>对节点 c 重复第 1 步；</li>
</ol>
<p>则上图中树的遍历结果为：5, 25, 20, 66, 80, 75, 50, 92, 111, 95, 166, 200, 175, 150, 90。</p>
<h3 id="代码举例-15">代码举例</h3>
<pre><code class="language-java">import java.util.Random;

//二叉查找树
public class BST&lt;Key extends Comparable&lt;Key&gt;, Value&gt;
{
	private Node root;		//二叉查找树的根节点
	
	private class Node
	{
		private Key key;	//键
		private Value val;	//值
		private Node left, right;//指向子树的节点
		private int N;		//以该节点为根的子树中的节点总数
		
		private Node(Key key, Value val, int N)
		{
			//构造函数
			this.key = key;
			this.val = val;
			this.N = N;
		}
	}
	
	public int size()
	{
		return size(root);
	}
	private int size(Node x)
	{
		if(x == null)
			return 0;
		else
			return x.N;
	}
	public Value get(Key key)
	{
		return get(root, key);
	}
	private Value get(Node x, Key key)
	{
		//在以x为根节点的子树中查找并返回key所对应的值
		//如果找不到则返回null
		if(x == null)
			return null;
		int cmp = key.compareTo(x.key);
		if		(cmp &lt; 0)
			return get(x.left, key);
		else if (cmp &gt; 0)
			return get(x.right, key);
		else
			return x.val;
	}
	
	public void put(Key key, Value val)
	{
		//查找key,找到则更新它的值，否则为它创建一个新的节点
		root = put(root, key, val);
	}
	private Node put(Node x, Key key, Value val)
	{
		//如果key存在于以x为根节点的子树中则更新它的值
		//否则将以key和val为键值对的新节点插入到该子树中
		if(x == null)
			return new Node(key, val, 1);
		int cmp = key.compareTo(x.key);
		//递归实现，相当美妙
		if		(cmp &lt; 0)
			x.left = put(x.left, key, val);
		else if (cmp &gt; 0)
			x.right = put(x.right, key, val);
		else
			x.val = val;
		x.N = size(x.left) + size(x.right) + 1;
		return x;
	}
	public Key min()
	{
		return min(root).key;
	}
	private Node min(Node x)
	{
		if(x.left == null) return x;
		return min(x.left);
	}
	public Key max()
	{
		return max(root).key;
	}
	private Node max(Node x)
	{
		if(x.right == null) return x;
		return min(x.right);
	}
	public Key floor(Key key)
	{
		//找出小于等于key的最大键
		Node x = floor(root, key);
		if(x == null) return null;
		return x.key;
	}
	public Key ceiling(Key key)
	{
		//找出大于key的最小键
		Node x = ceiling(root, key);
		if(x == null) return null;
		return x.key;
	}
	private Node floor(Node x, Key key)
	{
		if(x == null) return null;
		int cmp = key.compareTo(x.key);
		if(cmp == 0) return x;
		if(cmp &lt; 0)  return floor(x.left, key);
		Node t = floor(x.right, key);
		if(t != null) return t;
		else		  return x;
	}
	private Node ceiling(Node x, Key key)
	{
		if(x == null) return null;
		int cmp = key.compareTo(x.key);
		if(cmp == 0) return x;
		if(cmp &gt; 0)  return floor(x.right, key);
		Node t = floor(x.left, key);
		if(t != null) return t;
		else		  return x;
	}
	public Key select(int k)
	{
		return select(root, k).key;
	}
	private Node select(Node x, int k)
	{
		//返回排名为k的节点
		if(x == null) return null;
		int t = size(x.left);
		if		(t &gt; k) return select(x.left, k);
		else if (t &lt; k) return select(x.right, k-t-1);
		else			return x;
	}
	public int rank(Key key)
	{
		return rank(key, root);
	}
	private int rank(Key key, Node x)
	{
		//返回以x为根节点的子树中小于x.key的键的数量
		if(x == null) return 0;
		int cmp = key.compareTo(x.key);
		if			(cmp &lt; 0) 
			return rank(key, x.left);
		else if		(cmp &gt; 0)
			return 1 + size(x.left) + rank(key, x.right);
		else
			return size(x.left);
	}
	public void deleteMin()
	{
		root = deleteMin(root);
	}
	private Node deleteMin(Node x)
	{
		if(x.left == null) return x.right;
		x.left = deleteMin(x.left);
		x.N = size(x.left) + size(x.right) + 1;
		return x;
	}
	public void deleteMin(Key key)
	{
		root = delete(root, key);
	}
	private Node delete(Node x, Key key)
	{
		//二叉查找树删除节点操作，难点
		if(x == null)
			return null;
		int cmp = key.compareTo(x.key);
		if		(cmp &lt; 0)
			x.left = delete(x.left, key);
		else if (cmp &gt; 0)
			x.right = delete(x.right, key);
		else
		{
			//此时cmp == 0，说明已经到达要删除的节点
			//剩下的工作是判断该节点有几个子节点
			if(x.right == null) return x.left;
			if(x.left == null)  return x.right;
			//很奇怪，如果左右节点都为空，那么上面的的操作不会返回一个Null吗
			Node t = x;
			x = min(t.right);
			x.right = deleteMin(t.right);
			x.left = t.left;
		}
		x.N = size(x.left) + size(x.right) + 1;
		return x;
	}
	private void print(Node x)
	{
		if(x == null) return;
		print(x.left);
		System.out.print(x.key+&quot; &quot;);
		print(x.right);
	}
	public Iterable&lt;Key&gt; key()
	{
		//这个函数返回一个存有整个二叉查找树的队列
		return keys(min(), max());
	}
	public Iterable&lt;Key&gt; keys(Key lo, Key hi)
	{
		//这个函数返回一个存有[lo...hi]的二叉查找树的队列
		LinkListQueue&lt;Key&gt; queue = new LinkListQueue&lt;Key&gt;();
		keys(root, queue, lo, hi);
		return queue;
	}
	private void keys(Node x, LinkListQueue&lt;Key&gt; queue, Key lo, Key hi)
	{
		//这个函数将二叉查找树转成队列
		if(x == null) return;
		int cmplo = lo.compareTo(x.key);
		int cmphi = hi.compareTo(x.key);
		if(cmplo &lt; 0) 
			keys(x.left, queue, lo, hi);
		if(cmplo &lt;= 0 &amp;&amp; cmphi &gt;= 0)
			queue.enqueue(x.key);
		if(cmphi &gt; 0)
			keys(x.right, queue, lo, hi);
	}
	
	public static void main(String[] args)
	{
		BST&lt;Integer, String&gt; bst = new BST&lt;Integer, String&gt;();
		Random r = new Random(1);
		for(int i = 0; i &lt; 10000; i++)
		{
			bst.put(i,r.nextInt()%10000 + &quot;&quot;);
		}
	}

}
</code></pre>
<h2 id="红黑树">红黑树😅</h2>
<p>过于复杂😭，之后再补充</p>
<h2 id="哈希表">哈希表🥪</h2>
<p>有时，我们会想，如果一个<strong>键值对</strong>的键直接用来当数组的下标，那么我们查找这个值时，不就能很快找到这个值吗。然鹅现实很骨感！如果它的键不是整数怎么办，如果它的键是一个很大的整数怎么办？比如，对于键值对&lt;key: 10000000000,  val: “lisa”&gt;，我们要能快速查询，就要有一个数组至少有10000000000的内存空间，才能满足a[10000000000] = &quot;lisa&quot;这个操作。因此，我们需要将其转换。而转换的方法，也就是<strong>散列表</strong>（也称哈希表）的关键。</p>
<h3 id="散列函数">散列函数</h3>
<p>我们的主要问题是，<strong>怎么把不同类型的键用一个函数转换成一系列整数，使它们成为数组的索引</strong>，并且保证这些数不重复，而且便于计算，还能均匀分布在个各区间上（即对于M个键值对，0到M-1直接的每个整数都有相等的机会与之对应）<br>
<img src="https://shame41.github.io/post-images/1615888623924.jpg" alt="" loading="lazy"></p>
<p>而散列函数的构建是一个极其高深的数学问题，我们这里举几个简单的例子</p>
<h4 id="正整数">正整数</h4>
<p>我们有一系列整数，要构建它的散列函数，最常用的方法是<strong>除留余数法</strong>。我们选择一个<mark>大小为素数M的数组</mark>，对于任意正整数k，计算k%M。</p>
<p>这样，我们得到的一系列整数能将键有效地分布在0到M-1的范围内。</p>
<h4 id="浮点数">浮点数</h4>
<p>如果键是0到1之间的实数，我们可以将它<strong>乘以M并四舍五入得到一个0到M-1的索引值</strong>。</p>
<p>但是这种方法有缺陷。因为这种情况下键的高位起的作用更大，最低位对散列的结果没有影响。一种优化的方法是<strong>将键表示成二进制然后再使用除留余数法</strong>（Java就是这么做的）</p>
<h4 id="字符串">字符串</h4>
<p>我们可以简单地把字符串当作大整数，这样我们就可以使用<strong>除留余数法</strong>。</p>
<pre><code class="language-java">int hash = 0;
for(int i = 0; i &lt; s.length; i++)
	hash = (R * hash + s.charAt(i)) % M;
//charAt()能返回一个char值，即一个非负16位整数
</code></pre>
<h4 id="哈希码">哈希码</h4>
<p>JAVA为每种数据类型都继承了一个能返回32比特整数的hashCode()方法。我们可以将hashCode()的返回值转化为一个数组索引。具体方法如下</p>
<pre><code class="language-java">private int hash(Key x)
{
	return (x.hashCode() &amp; 0x7fffffff) % M;
}
</code></pre>
<p>这段代码会将符号位屏蔽，然后用除留余数法计算它除以M的余数。在使用这种代码时，我们一般会将数组的大小M取为<strong>素数</strong>以充分利用原散列值的所有位</p>
<h3 id="拉链法处理碰撞">拉链法处理碰撞</h3>
<p>前面我们解决了第一个问题：如和将键转换为数组索引，接下来我们要处理第二个问题：<strong>散列值碰撞</strong>，即两个或多个值的散列值相同。 一种直接的方法就是将得到的<mark>大小为M的数组的每个元素都指向一条链表</mark>，链表中的每个结点都储存了散列值为该元素的索引的键值对。这种方法称作<strong>拉链法</strong>。</p>
<p>基本思想是：选择足够大的M，使得<strong>所有链表都能尽可能短</strong>以保证高效地查找。</p>
<p>查找分为两步：1.根据散列值找到对应的链表，2.然后沿着链表顺序查找相应的键。<br>
<img src="https://shame41.github.io/post-images/1615957522860.png" alt="" loading="lazy"><br>
因为我们用M条链表来保持N个键，无论键在各个链表中分布如何，链表的平均长度肯定都是N/M。<br>
####代码举例</p>
<pre><code class="language-java">public class SeparateChainingHashST&lt;Key, Value&gt;
{
	private int N;			//键值对总数
	private int M;			//散列表的大小
	private SeparateChainingHashST&lt;Key, Value&gt;[] st;//存放链表的数组

	public SeparateChainingHashST()
	{
		this(997);
	}
	public SeparateChainingHashST(int M)
	{
		//创建M条链表
		this.M = M;
		st = (SeparateChainingHashST&lt;Key, Value&gt;[]) new SeparateChainingHashST[M];
		for(int i=0; i&lt;M; i++)
			st[i] = new SeparateChainingHashST();
	}
	private int hash(Key key)
	{
		return (key.hashCode() &amp; 0x7fffffff) % M;
	}
	public Value get(Key key)
	{
		return (Value) st[hash(key)].get(key);
	}
	public void put(Key key, Value val)
	{
		st[hash(key)].put(key, val);
	}
//	public Iterable&lt;Key&gt; keys()
//	{
//		
//	}
	public static void main(String[] args)
	{
		// TODO Auto-generated method stub
		SeparateChainingHashST a = new SeparateChainingHashST(7);
		a.put(1, 'E');
	}

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Typora基本用法 ]]></title>
        <id>https://shame41.github.io/post/typora-ji-ben-yong-fa/</id>
        <link href="https://shame41.github.io/post/typora-ji-ben-yong-fa/">
        </link>
        <updated>2021-03-06T15:18:20.000Z</updated>
        <content type="html"><![CDATA[<p><mark>（1）标题</mark></p>
<h1 id="一级标题">一级标题</h1>
<h2 id="二级标题">二级标题</h2>
<h3 id="三级标题">三级标题</h3>
<h4 id="四级标题">四级标题</h4>
<h5 id="五级标题">五级标题</h5>
<h6 id="六级标题">六级标题</h6>
<p><mark>（2）字体</mark></p>
<p><strong>加粗</strong></p>
<p><em>斜体</em></p>
<p><em><strong>斜体加粗</strong></em></p>
<p><s>删除线</s></p>
<p><mark>高亮</mark></p>
<p>我是<sup>上标</sup></p>
<p>我是<sub>下标</sub></p>
<p><mark>（3）列表</mark></p>
<ul>
<li>
<p>一二三四五</p>
<ul>
<li>
<p>上山打老虎</p>
<ul>
<li>
<p>老虎没打到</p>
<ul>
<li>打到小松鼠</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>
<p>一二三四五</p>
</li>
<li>
<p>上山打老虎</p>
</li>
<li>
<p>老虎没打到</p>
</li>
<li>
<p>打到小松鼠</p>
</li>
</ol>
<p><mark>（4）表格</mark></p>
<p>| Mon    | TUE    | WED    | THU    | FRI    |</p>
<p>| ------ | ------ | ------ | ------ | ------ |</p>
<p>| 上山   | 上山   | 上山   | 上山   | 上山   |</p>
<p>| 打老虎 | 打老虎 | 打老虎 | 打老虎 | 打老虎 |</p>
<p><mark>（5）引用</mark></p>
<blockquote>
<p>一二三四五</p>
</blockquote>
<blockquote>
<blockquote>
<p>上山打老虎</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>老虎没打到</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>打到小松鼠</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p><mark>（6）分割线</mark></p>
<hr>
<p><mark>（7）代码</mark></p>
<p><code>我是代码</code></p>
<pre><code>
我是代码框

</code></pre>
]]></content>
    </entry>
</feed>